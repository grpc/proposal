C-core Endpoint Extensibility API
----
* Author(s): Michael Lumish
* Approver: ctiller
* Status: Draft
* Implemented in: C-Core
* Last updated: 2017-01-27
* Discussion at: https://groups.google.com/forum/#!topic/grpc-io/oIbBfPVO0lY

## Abstract

Provide C-Core APIs for applications to use custom TCP-like endpoints.

## Background

Endpoints are the lowest-level networking layer in the gRPC core. The most
commonly used endpoint is the TCP implementation. We have seen increasing
demand for different endpoint implementations, including alternate TCP stacks
and TCP-like protocols. Some of these would be too special-case to support
within the gRPC core itself.

## Proposal

We will create `include/grpc/ext/tcp_client.h` and `include/grpc/ext/tcp_server.h`,
based on `src/core/lib/iomgr/tcp_client.h` and `src/core/lib/iomgr/tcp_server.h`
respectively, with vtable definitions in place of function definitions to allow
for extensibility as follows:

### `tcp_client.h`

```c
typedef struct grpc_tcp_client grpc_tcp_client;
typedef struct grpc_tcp_client_vtable {
  void (*connect)(grpc_exec_ctx *exec_ctx, grpc_closure *on_connect,
                  grpc_endpoint **endpoint,
                  grpc_pollset_set *interested_parties,
                  const grpc_channel_args *channel_args,
                  const grpc_resolved_address *addr,
                  gpr_timespec deadline);
  void (*ref)(grpc_tcp_client *client);
  void (*unref)(grpc_exec_ctx *exec_ctx, grpc_tcp_client *client);
} grpc_tcp_client_vtable;


struct grpc_tcp_client {
  const grpc_tcp_client_vtable *vtable;
};
```

### `tcp_server.h`

```c
typedef struct grpc_tcp_server_acceptor // as currently defined;
typedef void (*grpc_tcp_server_cb) // as currently defined;
typedef struct grpc_tcp_server grpc_tcp_server;


typedef struct grpc_tcp_server_vtable {
  void (*start)(grpc_exec_ctx *exec_ctx, grpc_tcp_server *server,
                grpc_pollset **pollsets, size_t pollset_count,
                grpc_tcp_server_cb on_accept_cb, void *cb_arg);
  void (*add_port)(grpc_tcp_server *s,
                   const grpc_resolved_address *addr,
                   int *out_port);
  void (*ref)(grpc_tcp_server *s);
  void (*unref)(grpc_exec_ctx *exec_ctx, grpc_tcp_server *s);
  void (*shutdown_starting_add)(grpc_tcp_server *s,
                                grpc_closure *shutdown_starting);
} grpc_tcp_server_vtable;


struct grpc_tcp_server {
  const grpc_tcp_server_vtable *vtable;
};


typedef struct grpc_tcp_server_factory grpc_tcp_server_factory;


typedef struct grpc_tcp_server_factory_vtable {
  void (*create_server)(grpc_exec_ctx *exec_ctx,
                        grpc_closure *shutdown_complete,
                        const grpc_channel_args *args,
                        grpc_tcp_server **server);
  void (*ref)(grpc_tcp_server_factory *f);
  void (*unref)(grpc_exec_ctx *exec_ctx, grpc_tcp_server_factory *f);
} grpc_tcp_server_factory_vtable;


struct grpc_tcp_server_factory {
  const grpc_tcp_server_factory_vtable *vtable;
};
```

The existing headers with function declarations will stay internal, and
`src/core/lib/iomgr/endpoint.h` will be split, with the vtable and struct
definitions moved to `include/grpc/ext/endpoint.h`, and the function
declarations staying in an internal header. Like with the endpoint code,
the only explicit implementations of the client and server interfaces will be
vtable calls, and the existing implementations will change to define vtables.


We will also add two channel arg keys to allow API users to use their TCP
implementations with their channel or server: `"grpc.tcp.client"`, which will
have a pointer value of type `grpc_tcp_client*` and `"grpc.tcp.server_factory"`,
which will have a pointer value of type `grpc_tcp_server_factory*`.

These interfaces use types from other iomgr headers, so the following headers
from `src/core/iomgr/` will move to `include/grpc/ext`:

 - `closure.h`
 - `error.h`
 - `exec_ctx.h`
 - `pollset.h`
 - `pollset_set.h`
 - `resolve_address.h`
 - `resource_quota.h`

and `src/core/lib/support/mpscq.h` will move to `include/grpc/support`.

## Rationale

The channel arguments API is an existing interface for users of gRPC to
parameterize low-level core functionality, so it is a good place to add the
extension point for endpoint implementations. In addition, using vtables for
extensibility is a stategy already used in several places throughout the
C-core, so using it here is simply a small expansion of an established pattern.


## Implementation

This should be straightforwardly implementable in the C core.
